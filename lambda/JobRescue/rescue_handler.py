from calcloud import io
from calcloud import hst
from calcloud import lambda_submit


RESCUE_TYPES = ["error", "terminated"]

MAX_PER_LAMBDA = 100


def lambda_handler(event, context):

    # Decode the S3 event message generated by the message write operation.
    # See S3 docs: https://docs.aws.amazon.com/AmazonS3/latest/userguide/notification-content-structure.html
    bucket_name = event["Records"][0]["s3"]["bucket"]["name"]
    message = event["Records"][0]["s3"]["object"]["key"]
    ipst = message.split("-")[-1]
    print(f"received {message} on bucket s3://{bucket_name}")
    assert hst.IPPPSSOOT_RE.match(ipst) or ipst == "all", "Bad ipppssoot value: " + repr(ipst)

    comm = io.get_io_bundle(bucket_name)

    fail_ipsts = set()
    if ipst == "all":
        print("Rescuing all")
        for type in RESCUE_TYPES:
            ipsts = [msg.split("-")[-1] for msg in comm.messages.list(f"{type}-all", max_objects=MAX_PER_LAMBDA)]
            fail_ipsts |= set(ipsts)
        for this in fail_ipsts:  # call lambdas for paralellism
            comm.messages.put(f"rescue-{this}")
        if len(fail_ipsts) == MAX_PER_LAMBDA:
            comm.messages.put("rescue-all")  # re-trigger next 0 <= x <= 100 rescues,  don't bother deleting first
        else:
            comm.messages.delete_literal("rescue-all")  # delete 'rescue-all' only,  not individual ipppssoot versions
    else:
        print("Rescuing", ipst)
        comm.outputs.delete(ipst)
        comm.messages.delete(f"all-{ipst}")
        # control file required for retries
        # inputs required for retries
        lambda_submit.main(ipst, bucket_name)
